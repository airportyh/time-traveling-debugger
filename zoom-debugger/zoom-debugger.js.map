{"version":3,"sources":["webpack://ZoomDebugger/webpack/universalModuleDefinition","webpack://ZoomDebugger/webpack/bootstrap","webpack://ZoomDebugger/./node_modules/moo/moo.js","webpack://ZoomDebugger/./node_modules/nearley/lib/nearley.js","webpack://ZoomDebugger/./src/lexer.js","webpack://ZoomDebugger/./src/parser.js","webpack://ZoomDebugger/./src/play-lang.js","webpack://ZoomDebugger/./src/traverser.js","webpack://ZoomDebugger/./src/zoom-debugger/code-scope-renderer.ts","webpack://ZoomDebugger/./src/zoom-debugger/fit-box.ts","webpack://ZoomDebugger/./src/zoom-debugger/index.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA,MAAM,IAA0C;AAChD,IAAI,iCAAO,EAAE,oCAAE,OAAO;AAAA;AAAA;AAAA,oGAAC;AACvB,GAAG,MAAM,EAIN;AACH,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;;AAEA,wBAAwB;AACxB,wBAAwB;;AAExB;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C,oCAAoC;AACnF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA,sBAAsB,cAAc;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA,sCAAsC;AACtC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,OAAO;AACP,kBAAkB;AAClB;AACA,gBAAgB;AAChB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8CAA8C;AAC9C;AACA,GAAG,yBAAyB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,oCAAoC,cAAc;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC,6BAA6B,eAAe;AAC5C;AACA;;AAEA,CAAC;;;;;;;;;;;;AC/jBD;AACA,QAAQ,KAA0B;AAClC;AACA,KAAK;AACL;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,qCAAqC;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,4BAA4B;AAC5B,4BAA4B;AAC5B;;;AAGA;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB,OAAO;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA,iDAAiD,KAAK,IAAI;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qDAAqD,EAAE;AACnG;AACA,wBAAwB;AACxB;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2DAA2D;AAC3G;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,+CAA+C,cAAc,EAAE;AAC/D;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;;;;;ACveD,YAAY,mBAAO,CAAC,sCAAK;;AAEzB;AACA;AACA,SAAS,gCAAgC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;;AAED;;;;;;;;;;;;ACzDA,gBAAgB,mBAAO,CAAC,sDAAS;AACjC,gBAAgB,mBAAO,CAAC,uCAAa;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACdA;AACA;AACA;AACA,gBAAgB,aAAa;;AAE7B,cAAc,mBAAO,CAAC,+BAAS;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,aAAa;AACb,KAAK;AACL;AACA,iBAAiB;AACjB,KAAK,yEAAyE,eAAe;AAC7F;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK,kDAAkD,eAAe;AACtE;AACA,iBAAiB;AACjB,KAAK;AACL;AACA,iBAAiB;AACjB,KAAK,qFAAqF;AAC1F,KAAK,8EAA8E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C,6BAA6B;AAC1J,KAAK;AACL;AACA;AACA;AACA,IAAI,KAA6B;AACjC;AACA,CAAC;AACD;AACA;AACA,CAAC;;;;;;;;;;;;ACpXD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK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","file":"zoom-debugger.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ZoomDebugger\"] = factory();\n\telse\n\t\troot[\"ZoomDebugger\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/zoom-debugger/index.ts\");\n","(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory) /* global define */\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory()\n  } else {\n    root.moo = factory()\n  }\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n  var toString = Object.prototype.toString\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }\n  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)'\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')\n      if (obj.global) throw new Error('RegExp /g flag is implied')\n      if (obj.sticky) throw new Error('RegExp /y flag is implied')\n      if (obj.multiline) throw new Error('RegExp /m flag is implied')\n      if (obj.unicode) throw new Error('RegExp /u flag is not allowed')\n      return obj.source\n\n    } else {\n      throw new Error('Not a pattern: ' + obj)\n    }\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = [].concat(thing)\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({include: rules[j]})\n        }\n        continue\n      }\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i]\n      if (obj.include) {\n        var include = [].concat(obj.include)\n        for (var j = 0; j < include.length; j++) {\n          result.push({include: include[j]})\n        }\n        continue\n      }\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.type, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = { match: obj }\n    }\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states')\n    }\n\n    // nb. error and fallback imply lineBreaks\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false,\n    }\n\n    // Avoid Object.assign(), so we support IE9+\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key]\n      }\n    }\n\n    // type transform cannot be a string\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\")\n    }\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    return options\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)\n  }\n\n  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})\n  function compileRules(rules, hasStates) {\n    var errorRule = null\n    var fast = Object.create(null)\n    var fastAllowed = true\n    var groups = []\n    var parts = []\n\n    // If there is a fallback rule, then disable fast matching\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i]\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers')\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\")\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\")\n          }\n        }\n        errorRule = options\n      }\n\n      var match = options.match\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift()\n          fast[word.charCodeAt(0)] = options\n        }\n      }\n\n      // Warn about inappropriate state-switching options\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\")\n        }\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\")\n        }\n      }\n\n      // Only rules with a .match are included in the RegExp\n      if (match.length === 0) {\n        continue\n      }\n      fastAllowed = false\n\n      groups.push(options)\n\n      // convert to RegExp\n      var pat = reUnion(match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?:  ) instead\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n\n    // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n    var fallbackRule = errorRule && errorRule.fallback\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'\n    var suffix = hasSticky || fallbackRule ? '' : '|'\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n\n    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules))\n    return new Lexer({start: result}, 'start')\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next)\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n  }\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : []\n    delete states.$all\n\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var ruleMap = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      ruleMap[key] = toRules(states[key]).concat(all)\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var rules = ruleMap[key]\n      var included = Object.create(null)\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j]\n        if (!rule.include) continue\n        var splice = [j, 1]\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true\n          var newRules = ruleMap[rule.include]\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\")\n          }\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k]\n            if (rules.indexOf(newRule) !== -1) continue\n            splice.push(newRule)\n          }\n        }\n        rules.splice.apply(rules, splice)\n        j--\n      }\n    }\n\n    var map = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(ruleMap[key], true)\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i]\n      var state = map[name]\n      var groups = state.groups\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map)\n      }\n      var fastKeys = Object.getOwnPropertyNames(state.fast)\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map)\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n    var reverseMap = Object.create(null)\n    var byLength = Object.create(null)\n    var types = Object.getOwnPropertyNames(map)\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword)\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        reverseMap[keyword] = tokenType\n      })\n    }\n\n    // fast string lookup\n    // https://jsperf.com/string-lookups\n    function str(x) { return JSON.stringify(x) }\n    var source = ''\n    source += 'switch (value.length) {\\n'\n    for (var length in byLength) {\n      var keywords = byLength[length]\n      source += 'case ' + length + ':\\n'\n      source += 'switch (value) {\\n'\n      keywords.forEach(function(keyword) {\n        var tokenType = reverseMap[keyword]\n        source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\\n'\n      })\n      source += '}\\n'\n    }\n    source += '}\\n'\n    return Function('value', source) // type\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.queuedToken = info ? info.queuedToken : null\n    this.queuedThrow = info ? info.queuedThrow : null\n    this.setState(info ? info.state : this.startState)\n    this.stack = info && info.stack ? info.stack.slice() : []\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedThrow: this.queuedThrow,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error\n    this.re = info.regexp\n    this.fast = info.fast\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  var eat = hasSticky ? function(re, buffer) { // assume re is /y\n    return re.exec(buffer)\n  } : function(re, buffer) { // assume re is /g\n    var match = re.exec(buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i]\n      }\n    }\n    throw new Error('Cannot find token type for matched text')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var index = this.index\n\n    // If a fallback token matched, we don't need to re-run the RegExp\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index)\n      this.queuedGroup = null\n      this.queuedText = \"\"\n      return token\n    }\n\n    var buffer = this.buffer\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    // Fast matching for single characters\n    var group = this.fast[buffer.charCodeAt(index)]\n    if (group) {\n      return this._token(group, buffer.charAt(index), index)\n    }\n\n    // Execute RegExp\n    var re = this.re\n    re.lastIndex = index\n    var match = eat(re, buffer)\n\n    // Error tokens match the remaining buffer\n    var error = this.error\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index)\n    }\n\n    var group = this._getGroup(match)\n    var text = match[0]\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group\n      this.queuedText = text\n\n      // Fallback tokens contain the unmatched portion of the buffer\n      return this._token(error, buffer.slice(index, match.index), index)\n    }\n\n    return this._token(group, text, index)\n  }\n\n  Lexer.prototype._token = function(group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      throw new Error(this.formatError(token, \"invalid syntax\"))\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    var value = token.text\n    var index = token.offset\n    var eol = token.lineBreaks ? value.indexOf('\\n') : value.length\n    var start = Math.max(0, index - token.col + 1)\n    var firstLine = this.buffer.substring(start, index + eol)\n    message += \" at line \" + token.line + \" col \" + token.col + \":\\n\\n\"\n    message += \"  \" + firstLine + \"\\n\"\n    message += \"  \" + Array(token.col).join(\" \") + \"^\"\n    return message\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    return true\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n    fallback: Object.freeze({fallback: true}),\n    keywords: keywordTransform,\n  }\n\n}));\n","(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\n    function Rule(name, symbols, postprocess) {\n        this.id = ++Rule.highestId;\n        this.name = name;\n        this.symbols = symbols;        // a list of literal | regex class | nonterminal\n        this.postprocess = postprocess;\n        return this;\n    }\n    Rule.highestId = 0;\n\n    Rule.prototype.toString = function(withCursorAt) {\n        function stringifySymbolSequence (e) {\n            return e.literal ? JSON.stringify(e.literal) :\n                   e.type ? '%' + e.type : e.toString();\n        }\n        var symbolSequence = (typeof withCursorAt === \"undefined\")\n                             ? this.symbols.map(stringifySymbolSequence).join(' ')\n                             : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')\n                                 + \"  \"\n                                 + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );\n        return this.name + \"  \" + symbolSequence;\n    }\n\n\n    // a State is a rule at a position from a given starting point in the input stream (reference)\n    function State(rule, dot, reference, wantedBy) {\n        this.rule = rule;\n        this.dot = dot;\n        this.reference = reference;\n        this.data = [];\n        this.wantedBy = wantedBy;\n        this.isComplete = this.dot === rule.symbols.length;\n    }\n\n    State.prototype.toString = function() {\n        return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n    };\n\n    State.prototype.nextState = function(child) {\n        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n        state.left = this;\n        state.right = child;\n        if (state.isComplete) {\n            state.data = state.build();\n        }\n        return state;\n    };\n\n    State.prototype.build = function() {\n        var children = [];\n        var node = this;\n        do {\n            children.push(node.right.data);\n            node = node.left;\n        } while (node.left);\n        children.reverse();\n        return children;\n    };\n\n    State.prototype.finish = function() {\n        if (this.rule.postprocess) {\n            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n        }\n    };\n\n\n    function Column(grammar, index) {\n        this.grammar = grammar;\n        this.index = index;\n        this.states = [];\n        this.wants = {}; // states indexed by the non-terminal they expect\n        this.scannable = []; // list of states that expect a token\n        this.completed = {}; // states that are nullable\n    }\n\n\n    Column.prototype.process = function(nextColumn) {\n        var states = this.states;\n        var wants = this.wants;\n        var completed = this.completed;\n\n        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n            var state = states[w];\n\n            if (state.isComplete) {\n                state.finish();\n                if (state.data !== Parser.fail) {\n                    // complete\n                    var wantedBy = state.wantedBy;\n                    for (var i = wantedBy.length; i--; ) { // this line is hot\n                        var left = wantedBy[i];\n                        this.complete(left, state);\n                    }\n\n                    // special-case nullables\n                    if (state.reference === this.index) {\n                        // make sure future predictors of this rule get completed.\n                        var exp = state.rule.name;\n                        (this.completed[exp] = this.completed[exp] || []).push(state);\n                    }\n                }\n\n            } else {\n                // queue scannable states\n                var exp = state.rule.symbols[state.dot];\n                if (typeof exp !== 'string') {\n                    this.scannable.push(state);\n                    continue;\n                }\n\n                // predict\n                if (wants[exp]) {\n                    wants[exp].push(state);\n\n                    if (completed.hasOwnProperty(exp)) {\n                        var nulls = completed[exp];\n                        for (var i = 0; i < nulls.length; i++) {\n                            var right = nulls[i];\n                            this.complete(state, right);\n                        }\n                    }\n                } else {\n                    wants[exp] = [state];\n                    this.predict(exp);\n                }\n            }\n        }\n    }\n\n    Column.prototype.predict = function(exp) {\n        var rules = this.grammar.byName[exp] || [];\n\n        for (var i = 0; i < rules.length; i++) {\n            var r = rules[i];\n            var wantedBy = this.wants[exp];\n            var s = new State(r, 0, this.index, wantedBy);\n            this.states.push(s);\n        }\n    }\n\n    Column.prototype.complete = function(left, right) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n\n\n    function Grammar(rules, start) {\n        this.rules = rules;\n        this.start = start || this.rules[0].name;\n        var byName = this.byName = {};\n        this.rules.forEach(function(rule) {\n            if (!byName.hasOwnProperty(rule.name)) {\n                byName[rule.name] = [];\n            }\n            byName[rule.name].push(rule);\n        });\n    }\n\n    // So we can allow passing (rules, start) directly to Parser for backwards compatibility\n    Grammar.fromCompiled = function(rules, start) {\n        var lexer = rules.Lexer;\n        if (rules.ParserStart) {\n          start = rules.ParserStart;\n          rules = rules.ParserRules;\n        }\n        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n        var g = new Grammar(rules, start);\n        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n        return g;\n    }\n\n\n    function StreamLexer() {\n      this.reset(\"\");\n    }\n\n    StreamLexer.prototype.reset = function(data, state) {\n        this.buffer = data;\n        this.index = 0;\n        this.line = state ? state.line : 1;\n        this.lastLineBreak = state ? -state.col : 0;\n    }\n\n    StreamLexer.prototype.next = function() {\n        if (this.index < this.buffer.length) {\n            var ch = this.buffer[this.index++];\n            if (ch === '\\n') {\n              this.line += 1;\n              this.lastLineBreak = this.index;\n            }\n            return {value: ch};\n        }\n    }\n\n    StreamLexer.prototype.save = function() {\n      return {\n        line: this.line,\n        col: this.index - this.lastLineBreak,\n      }\n    }\n\n    StreamLexer.prototype.formatError = function(token, message) {\n        // nb. this gets called after consuming the offending token,\n        // so the culprit is index-1\n        var buffer = this.buffer;\n        if (typeof buffer === 'string') {\n            var nextLineBreak = buffer.indexOf('\\n', this.index);\n            if (nextLineBreak === -1) nextLineBreak = buffer.length;\n            var line = buffer.substring(this.lastLineBreak, nextLineBreak)\n            var col = this.index - this.lastLineBreak;\n            message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n            message += \"  \" + line + \"\\n\"\n            message += \"  \" + Array(col).join(\" \") + \"^\"\n            return message;\n        } else {\n            return message + \" at index \" + (this.index - 1);\n        }\n    }\n\n\n    function Parser(rules, start, options) {\n        if (rules instanceof Grammar) {\n            var grammar = rules;\n            var options = start;\n        } else {\n            var grammar = Grammar.fromCompiled(rules, start);\n        }\n        this.grammar = grammar;\n\n        // Read options\n        this.options = {\n            keepHistory: false,\n            lexer: grammar.lexer || new StreamLexer,\n        };\n        for (var key in (options || {})) {\n            this.options[key] = options[key];\n        }\n\n        // Setup lexer\n        this.lexer = this.options.lexer;\n        this.lexerState = undefined;\n\n        // Setup a table\n        var column = new Column(grammar, 0);\n        var table = this.table = [column];\n\n        // I could be expecting anything.\n        column.wants[grammar.start] = [];\n        column.predict(grammar.start);\n        // TODO what if start rule is nullable?\n        column.process();\n        this.current = 0; // token index\n    }\n\n    // create a reserved token for indicating a parse fail\n    Parser.fail = {};\n\n    Parser.prototype.feed = function(chunk) {\n        var lexer = this.lexer;\n        lexer.reset(chunk, this.lexerState);\n\n        var token;\n        while (token = lexer.next()) {\n            // We add new states to table[current+1]\n            var column = this.table[this.current];\n\n            // GC unused states\n            if (!this.options.keepHistory) {\n                delete this.table[this.current - 1];\n            }\n\n            var n = this.current + 1;\n            var nextColumn = new Column(this.grammar, n);\n            this.table.push(nextColumn);\n\n            // Advance all tokens that expect the symbol\n            var literal = token.text !== undefined ? token.text : token.value;\n            var value = lexer.constructor === StreamLexer ? token.value : token;\n            var scannable = column.scannable;\n            for (var w = scannable.length; w--; ) {\n                var state = scannable[w];\n                var expect = state.rule.symbols[state.dot];\n                // Try to consume the token\n                // either regex or literal\n                if (expect.test ? expect.test(value) :\n                    expect.type ? expect.type === token.type\n                                : expect.literal === literal) {\n                    // Add it\n                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                    nextColumn.states.push(next);\n                }\n            }\n\n            // Next, for each of the rules, we either\n            // (a) complete it, and try to see if the reference row expected that\n            //     rule\n            // (b) predict the next nonterminal it expects by adding that\n            //     nonterminal's start state\n            // To prevent duplication, we also keep track of rules we have already\n            // added\n\n            nextColumn.process();\n\n            // If needed, throw an error:\n            if (nextColumn.states.length === 0) {\n                // No states at all! This is not good.\n                var err = new Error(this.reportError(token));\n                err.offset = this.current;\n                err.token = token;\n                throw err;\n            }\n\n            // maybe save lexer state\n            if (this.options.keepHistory) {\n              column.lexerState = lexer.save()\n            }\n\n            this.current++;\n        }\n        if (column) {\n          this.lexerState = lexer.save()\n        }\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n\n        // Allow chaining, for whatever it's worth\n        return this;\n    };\n\n    Parser.prototype.reportError = function(token) {\n        var lines = [];\n        var tokenDisplay = (token.type ? token.type + \" token: \" : \"\") + JSON.stringify(token.value !== undefined ? token.value : token);\n        lines.push(this.lexer.formatError(token, \"Syntax error\"));\n        lines.push('Unexpected ' + tokenDisplay + '. Instead, I was expecting to see one of the following:\\n');\n        var lastColumnIndex = this.table.length - 2;\n        var lastColumn = this.table[lastColumnIndex];\n        var expectantStates = lastColumn.states\n            .filter(function(state) {\n                var nextSymbol = state.rule.symbols[state.dot];\n                return nextSymbol && typeof nextSymbol !== \"string\";\n            });\n        \n        // Display a \"state stack\" for each expectant state\n        // - which shows you how this state came to be, step by step. \n        // If there is more than one derivation, we only display the first one.\n        var stateStacks = expectantStates\n            .map(function(state) {\n                var stacks = this.buildStateStacks(state, []);\n                return stacks[0];\n            }, this);\n        // Display each state that is expecting a terminal symbol next.\n        stateStacks.forEach(function(stateStack) {\n            var state = stateStack[0];\n            var nextSymbol = state.rule.symbols[state.dot];\n            var symbolDisplay = this.getSymbolDisplay(nextSymbol);\n            lines.push('A ' + symbolDisplay + ' based on:');\n            this.displayStateStack(stateStack, lines);\n        }, this);\n            \n        lines.push(\"\");\n        return lines.join(\"\\n\");\n    };\n\n    Parser.prototype.displayStateStack = function(stateStack, lines) {\n        var lastDisplay;\n        var sameDisplayCount = 0;\n        for (var j = 0; j < stateStack.length; j++) {\n            var state = stateStack[j];\n            var display = state.rule.toString(state.dot);\n            if (display === lastDisplay) {\n                sameDisplayCount++;\n            } else {\n                if (sameDisplayCount > 0) {\n                    lines.push('     ' + sameDisplayCount + ' more lines identical to this');\n                }\n                sameDisplayCount = 0;\n                lines.push('    ' + display);\n            }\n            lastDisplay = display;\n        }\n    };\n\n    Parser.prototype.getSymbolDisplay = function(symbol) {\n        var type = typeof symbol;\n        if (type === \"string\") {\n            return symbol;\n        } else if (type === \"object\" && symbol.literal) {\n            return JSON.stringify(symbol.literal);\n        } else if (type === \"object\" && symbol instanceof RegExp) {\n            return 'character matching ' + symbol;\n        } else if (type === \"object\" && symbol.type) {\n            return symbol.type + ' token';\n        } else {\n            throw new Error('Unknown symbol type: ' + symbol);\n        }\n    };\n\n    /*\n    Builds a number of \"state stacks\". You can think of a state stack as the call stack\n    of the recursive-descent parser which the Nearley parse algorithm simulates.\n    A state stack is represented as an array of state objects. Within a \n    state stack, the first item of the array will be the starting\n    state, with each successive item in the array going further back into history.\n    \n    This function needs to be given a starting state and an empty array representing\n    the visited states, and it returns an array of state stacks. \n    \n    */\n    Parser.prototype.buildStateStacks = function(state, visited) {\n        if (visited.indexOf(state) !== -1) {\n            // Found cycle, return empty array (meaning no stacks)\n            // to eliminate this path from the results, because\n            // we don't know how to display it meaningfully\n            return [];\n        }\n        if (state.wantedBy.length === 0) {\n            return [[state]];\n        }\n        var that = this;\n\n        return state.wantedBy.reduce(function(stacks, prevState) {\n            return stacks.concat(that.buildStateStacks(\n                prevState,\n                [state].concat(visited))\n                .map(function(stack) {\n                    return [state].concat(stack);\n                }));\n        }, []);\n    };\n\n    Parser.prototype.save = function() {\n        var column = this.table[this.current];\n        column.lexerState = this.lexerState;\n        return column;\n    };\n\n    Parser.prototype.restore = function(column) {\n        var index = column.index;\n        this.current = index;\n        this.table[index] = column;\n        this.table.splice(index + 1);\n        this.lexerState = column.lexerState;\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n    };\n\n    // nb. deprecated: use save/restore instead!\n    Parser.prototype.rewind = function(index) {\n        if (!this.options.keepHistory) {\n            throw new Error('set option `keepHistory` to enable rewinding')\n        }\n        // nb. recall column (table) indicies fall between token indicies.\n        //        col 0   --   token 0   --   col 1\n        this.restore(this.table[index]);\n    };\n\n    Parser.prototype.finish = function() {\n        // Return the possible parsings\n        var considerations = [];\n        var start = this.grammar.start;\n        var column = this.table[this.table.length - 1]\n        column.states.forEach(function (t) {\n            if (t.rule.name === start\n                    && t.dot === t.rule.symbols.length\n                    && t.reference === 0\n                    && t.data !== Parser.fail) {\n                considerations.push(t);\n            }\n        });\n        return considerations.map(function(c) {return c.data; });\n    };\n\n    return {\n        Parser: Parser,\n        Grammar: Grammar,\n        Rule: Rule,\n    };\n\n}));\n","const moo = require(\"moo\");\n\nconst lexer = moo.compile({\n    ws: /[ \\t]+/,\n    nl: { match: \"\\n\", lineBreaks: true },\n    lte: \"<=\",\n    lt: \"<\",\n    gte: \">=\",\n    gt: \">\",\n    eq: \"==\",\n    ne: \"!=\",\n    not: \"!\",\n    lparan: \"(\",\n    rparan: \")\",\n    comma: \",\",\n    lbracket: \"[\",\n    rbracket: \"]\",\n    lbrace: \"{\",\n    rbrace: \"}\",\n    assignment: \"=\",\n    plus: \"+\",\n    minus: \"-\",\n    multiply: \"*\",\n    divide: \"/\",\n    modulo: \"%\",\n    colon: \":\",\n    comment: {\n        match: /#[^\\n]*/,\n        value: s => s.substring(1)\n    },\n    string_literal: {\n        match: /\"(?:[^\\n\\\\\"]|\\\\[\"\\\\ntbfr])*\"/,\n        value: s => JSON.parse(s)\n    },\n    number_literal: {\n        match: /[0-9]+(?:\\.[0-9]+)?/,\n        value: s => Number(s)\n    },\n    identifier: {\n        match: /[a-z_][a-zA-Z_0-9]*/,\n        type: moo.keywords({\n            def: \"def\",\n            while: \"while\",\n            for: \"for\",\n            else: \"else\",\n            in: \"in\",\n            if: \"if\",\n            return: \"return\",\n            and: \"and\",\n            or: \"or\",\n            true: \"true\",\n            false: \"false\",\n            break: \"break\"\n        })\n    }\n});\n\nmodule.exports = lexer;\n","const nearley = require(\"nearley\");\nconst grammar = require(\"./play-lang\");\n\nexports.parse = function parse(code) {\n    const parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));\n    parser.feed(code);\n    if (parser.results.length > 1) {\n        throw new Error(\"The parser found ambiguous parses.\");\n    }\n    if (parser.results.length === 0) {\n        throw new Error(\"No parses found. Input appeared to be incomplete.\");\n    }\n    const ast = parser.results[0];\n    return ast;\n}\n","// Generated automatically by nearley, version 2.19.0\n// http://github.com/Hardmath123/nearley\n(function () {\nfunction id(x) { return x[0]; }\n\nconst lexer = require(\"./lexer\");\n\nfunction tokenStart(token) {\n    return {\n        line: token.line,\n        col: token.col - 1,\n        offset: token.offset\n    };\n}\n\nfunction tokenEnd(token) {\n    const lastNewLine = token.text.lastIndexOf(\"\\n\");\n    if (lastNewLine !== -1) {\n        throw new Error(\"Unsupported case: token with line breaks\");\n    }\n    return {\n        line: token.line,\n        col: token.col + token.text.length - 1,\n        offset: token.offset + token.text.length\n    };\n}\n\nfunction convertToken(token) {\n    return {\n        type: token.type,\n        value: token.value,\n        start: tokenStart(token),\n        end: tokenEnd(token)\n    };\n}\n\nfunction convertTokenId(data) {\n    return convertToken(data[0]);\n}\n\nvar grammar = {\n    Lexer: lexer,\n    ParserRules: [\n    {\"name\": \"input\", \"symbols\": [\"top_level_statements\"], \"postprocess\": \n        d => ({\n            type: \"program\",\n            statements: d[0]\n        })\n            },\n    {\"name\": \"top_level_statements\", \"symbols\": [\"top_level_statement\"], \"postprocess\": \n        d => [d[0]]\n                },\n    {\"name\": \"top_level_statements\", \"symbols\": [\"top_level_statement\", \"_\", {\"literal\":\"\\n\"}, \"_\", \"top_level_statements\"], \"postprocess\": \n        d => [\n            d[0],\n            ...d[4]\n        ]\n                },\n    {\"name\": \"top_level_statements\", \"symbols\": [\"_\", {\"literal\":\"\\n\"}, \"top_level_statements\"], \"postprocess\": \n        d => d[2]\n                },\n    {\"name\": \"top_level_statements\", \"symbols\": [\"_\"], \"postprocess\": \n        d => []\n                },\n    {\"name\": \"top_level_statement\", \"symbols\": [\"function_definition\"], \"postprocess\": id},\n    {\"name\": \"top_level_statement\", \"symbols\": [\"line_comment\"], \"postprocess\": id},\n    {\"name\": \"function_definition\", \"symbols\": [{\"literal\":\"def\"}, \"__\", \"identifier\", \"_\", {\"literal\":\"(\"}, \"_\", \"parameter_list\", \"_\", {\"literal\":\")\"}, \"_\", \"code_block\"], \"postprocess\": \n        d => ({\n            type: \"function_definition\",\n            name: d[2],\n            parameters: d[6],\n            body: d[10],\n            start: tokenStart(d[0]),\n            end: d[10].end\n        })\n                },\n    {\"name\": \"parameter_list\", \"symbols\": [], \"postprocess\": () => []},\n    {\"name\": \"parameter_list\", \"symbols\": [\"identifier\"], \"postprocess\": d => [d[0]]},\n    {\"name\": \"parameter_list\", \"symbols\": [\"identifier\", \"_\", {\"literal\":\",\"}, \"_\", \"parameter_list\"], \"postprocess\": \n        d => [d[0], ...d[4]]\n                },\n    {\"name\": \"code_block\", \"symbols\": [{\"literal\":\"[\"}, \"executable_statements\", {\"literal\":\"]\"}], \"postprocess\": \n        (d) => ({\n            type: \"code_block\",\n            statements: d[1],\n            start: tokenStart(d[0]),\n            end: tokenEnd(d[2])\n        })\n            },\n    {\"name\": \"executable_statements\", \"symbols\": [\"_\"], \"postprocess\": () => []},\n    {\"name\": \"executable_statements\", \"symbols\": [\"_\", {\"literal\":\"\\n\"}, \"executable_statements\"], \"postprocess\": (d) => d[2]},\n    {\"name\": \"executable_statements\", \"symbols\": [\"_\", \"executable_statement\", \"_\"], \"postprocess\": d => [d[1]]},\n    {\"name\": \"executable_statements\", \"symbols\": [\"_\", \"executable_statement\", \"_\", {\"literal\":\"\\n\"}, \"executable_statements\"], \"postprocess\": \n        d => [d[1], ...d[4]]\n                },\n    {\"name\": \"executable_statement\", \"symbols\": [\"return_statement\"], \"postprocess\": id},\n    {\"name\": \"executable_statement\", \"symbols\": [\"var_assignment\"], \"postprocess\": id},\n    {\"name\": \"executable_statement\", \"symbols\": [\"call_statement\"], \"postprocess\": id},\n    {\"name\": \"executable_statement\", \"symbols\": [\"line_comment\"], \"postprocess\": id},\n    {\"name\": \"executable_statement\", \"symbols\": [\"indexed_assignment\"], \"postprocess\": id},\n    {\"name\": \"executable_statement\", \"symbols\": [\"while_loop\"], \"postprocess\": id},\n    {\"name\": \"executable_statement\", \"symbols\": [\"if_statement\"], \"postprocess\": id},\n    {\"name\": \"executable_statement\", \"symbols\": [\"for_loop\"], \"postprocess\": id},\n    {\"name\": \"executable_statement\", \"symbols\": [\"function_definition\"], \"postprocess\": id},\n    {\"name\": \"executable_statement\", \"symbols\": [\"break\"], \"postprocess\": id},\n    {\"name\": \"return_statement$ebnf$1$subexpression$1\", \"symbols\": [\"__\", \"expression\"]},\n    {\"name\": \"return_statement$ebnf$1\", \"symbols\": [\"return_statement$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"return_statement$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"return_statement\", \"symbols\": [{\"literal\":\"return\"}, \"return_statement$ebnf$1\"], \"postprocess\": \n        d => ({\n            type: \"return_statement\",\n            value: d[1] ? d[1][1] : null,\n            start: tokenStart(d[0]),\n            end: d[1] ? d[1][1].end : d[0].end\n        })\n               },\n    {\"name\": \"var_assignment\", \"symbols\": [\"identifier\", \"_\", {\"literal\":\"=\"}, \"_\", \"expression\"], \"postprocess\": \n        d => ({\n            type: \"var_assignment\",\n            var_name: d[0],\n            value: d[4],\n            start: d[0].start,\n            end: d[4].end\n        })\n                },\n    {\"name\": \"call_statement\", \"symbols\": [\"call_expression\"], \"postprocess\": id},\n    {\"name\": \"call_expression\", \"symbols\": [\"identifier\", \"_\", {\"literal\":\"(\"}, \"argument_list\", {\"literal\":\")\"}], \"postprocess\": \n        d => ({\n            type: \"call_expression\",\n            fun_name: d[0],\n            arguments: d[3],\n            start: d[0].start,\n            end: tokenEnd(d[4])\n        })\n                },\n    {\"name\": \"indexed_access\", \"symbols\": [\"unary_expression\", \"_\", {\"literal\":\"[\"}, \"_\", \"expression\", \"_\", {\"literal\":\"]\"}], \"postprocess\": \n        d => ({\n            type: \"indexed_access\",\n            subject: d[0],\n            index: d[4],\n            start: d[0].start,\n            end: tokenEnd(d[6])\n        })\n                },\n    {\"name\": \"indexed_assignment\", \"symbols\": [\"unary_expression\", \"_\", {\"literal\":\"[\"}, \"_\", \"expression\", \"_\", {\"literal\":\"]\"}, \"_\", {\"literal\":\"=\"}, \"_\", \"expression\"], \"postprocess\": \n        d => ({\n            type: \"indexed_assignment\",\n            subject: d[0],\n            index: d[4],\n            value: d[10],\n            start: d[0].start,\n            end: d[10].end\n        })\n                },\n    {\"name\": \"while_loop\", \"symbols\": [{\"literal\":\"while\"}, \"__\", \"expression\", \"__\", \"code_block\"], \"postprocess\": \n        d => ({\n            type: \"while_loop\",\n            condition: d[2],\n            body: d[4],\n            start: tokenStart(d[0]),\n            end: d[4].end\n        })\n                },\n    {\"name\": \"if_statement\", \"symbols\": [{\"literal\":\"if\"}, \"__\", \"expression\", \"__\", \"code_block\"], \"postprocess\": \n        d => ({\n            type: \"if_statement\",\n            condition: d[2],\n            consequent: d[4],\n            start: tokenStart(d[0]),\n            end: d[4].end\n        })\n                },\n    {\"name\": \"if_statement\", \"symbols\": [{\"literal\":\"if\"}, \"__\", \"expression\", \"_\", \"code_block\", \"_\", {\"literal\":\"else\"}, \"__\", \"code_block\"], \"postprocess\": \n        d => ({\n            type: \"if_statement\",\n            condition: d[2],\n            consequent: d[4],\n            alternate: d[8],\n            start: tokenStart(d[0]),\n            end: d[8].end\n        })\n                },\n    {\"name\": \"if_statement\", \"symbols\": [{\"literal\":\"if\"}, \"__\", \"expression\", \"_\", \"code_block\", \"_\", {\"literal\":\"else\"}, \"__\", \"if_statement\"], \"postprocess\": \n        d => ({\n            type: \"if_statement\",\n            condition: d[2],\n            consequent: d[4],\n            alternate: d[8],\n            start: tokenStart(d[0]),\n            end: d[8].end\n        })\n               },\n    {\"name\": \"for_loop\", \"symbols\": [{\"literal\":\"for\"}, \"__\", \"identifier\", \"__\", {\"literal\":\"in\"}, \"__\", \"expression\", \"_\", \"code_block\"], \"postprocess\": \n        d => ({\n            type: \"for_loop\",\n            loop_variable: d[2],\n            iterable: d[6],\n            body: d[8],\n            start: tokenStart(d[0]),\n            end: d[8].end\n        })\n                },\n    {\"name\": \"argument_list\", \"symbols\": [], \"postprocess\": () => []},\n    {\"name\": \"argument_list\", \"symbols\": [\"_\", \"expression\", \"_\"], \"postprocess\": d => [d[1]]},\n    {\"name\": \"argument_list\", \"symbols\": [\"_\", \"expression\", \"_\", {\"literal\":\",\"}, \"argument_list\"], \"postprocess\": \n        d => [d[1], ...d[4]]\n                },\n    {\"name\": \"expression\", \"symbols\": [\"boolean_expression\"], \"postprocess\": id},\n    {\"name\": \"boolean_expression\", \"symbols\": [\"comparison_expression\"], \"postprocess\": id},\n    {\"name\": \"boolean_expression\", \"symbols\": [\"comparison_expression\", \"_\", \"boolean_operator\", \"_\", \"boolean_expression\"], \"postprocess\": \n        d => ({\n            type: \"binary_operation\",\n            operator: convertToken(d[2]),\n            left: d[0],\n            right: d[4],\n            start: d[0].start,\n            end: d[4].end\n        })\n                },\n    {\"name\": \"boolean_operator\", \"symbols\": [{\"literal\":\"and\"}], \"postprocess\": id},\n    {\"name\": \"boolean_operator\", \"symbols\": [{\"literal\":\"or\"}], \"postprocess\": id},\n    {\"name\": \"comparison_expression\", \"symbols\": [\"additive_expression\"], \"postprocess\": id},\n    {\"name\": \"comparison_expression\", \"symbols\": [\"additive_expression\", \"_\", \"comparison_operator\", \"_\", \"comparison_expression\"], \"postprocess\": \n        d => ({\n            type: \"binary_operation\",\n            operator: d[2],\n            left: d[0],\n            right: d[4],\n            start: d[0].start,\n            end: d[4].end\n        })\n                },\n    {\"name\": \"comparison_operator\", \"symbols\": [{\"literal\":\">\"}], \"postprocess\": convertTokenId},\n    {\"name\": \"comparison_operator\", \"symbols\": [{\"literal\":\">=\"}], \"postprocess\": convertTokenId},\n    {\"name\": \"comparison_operator\", \"symbols\": [{\"literal\":\"<\"}], \"postprocess\": convertTokenId},\n    {\"name\": \"comparison_operator\", \"symbols\": [{\"literal\":\"<=\"}], \"postprocess\": convertTokenId},\n    {\"name\": \"comparison_operator\", \"symbols\": [{\"literal\":\"==\"}], \"postprocess\": convertTokenId},\n    {\"name\": \"comparison_operator\", \"symbols\": [{\"literal\":\"!=\"}], \"postprocess\": convertTokenId},\n    {\"name\": \"additive_expression\", \"symbols\": [\"multiplicative_expression\"], \"postprocess\": id},\n    {\"name\": \"additive_expression\", \"symbols\": [\"multiplicative_expression\", \"_\", /[+-]/, \"_\", \"additive_expression\"], \"postprocess\": \n        d => ({\n            type: \"binary_operation\",\n            operator: convertToken(d[2]),\n            left: d[0],\n            right: d[4],\n            start: d[0].start,\n            end: d[4].end\n        })\n                },\n    {\"name\": \"multiplicative_expression\", \"symbols\": [\"maybe_not_expression\"], \"postprocess\": id},\n    {\"name\": \"multiplicative_expression\", \"symbols\": [\"maybe_not_expression\", \"_\", /[*\\/%]/, \"_\", \"multiplicative_expression\"], \"postprocess\": \n        d => ({\n            type: \"binary_operation\",\n            operator: convertToken(d[2]),\n            left: d[0],\n            right: d[4],\n            start: d[0].start,\n            end: d[4].end\n        })\n                },\n    {\"name\": \"maybe_not_expression\", \"symbols\": [{\"literal\":\"!\"}, \"_\", \"unary_expression\"], \"postprocess\": \n        data => ({\n            type: \"not_operation\",\n            subject: data[2]\n        })\n                },\n    {\"name\": \"maybe_not_expression\", \"symbols\": [\"unary_expression\"], \"postprocess\": id},\n    {\"name\": \"unary_expression\", \"symbols\": [\"number\"], \"postprocess\": id},\n    {\"name\": \"unary_expression\", \"symbols\": [\"identifier\"], \"postprocess\": \n        d => ({\n            type: \"var_reference\",\n            var_name: d[0],\n            start: d[0].start,\n            end: d[0].end\n        })\n                },\n    {\"name\": \"unary_expression\", \"symbols\": [\"call_expression\"], \"postprocess\": id},\n    {\"name\": \"unary_expression\", \"symbols\": [\"string_literal\"], \"postprocess\": id},\n    {\"name\": \"unary_expression\", \"symbols\": [\"list_literal\"], \"postprocess\": id},\n    {\"name\": \"unary_expression\", \"symbols\": [\"dictionary_literal\"], \"postprocess\": id},\n    {\"name\": \"unary_expression\", \"symbols\": [\"boolean_literal\"], \"postprocess\": id},\n    {\"name\": \"unary_expression\", \"symbols\": [\"indexed_access\"], \"postprocess\": id},\n    {\"name\": \"unary_expression\", \"symbols\": [\"function_expression\"], \"postprocess\": id},\n    {\"name\": \"unary_expression\", \"symbols\": [{\"literal\":\"(\"}, \"expression\", {\"literal\":\")\"}], \"postprocess\": \n        data => data[1]\n                },\n    {\"name\": \"list_literal\", \"symbols\": [{\"literal\":\"[\"}, \"list_items\", {\"literal\":\"]\"}], \"postprocess\": \n        d => ({\n            type: \"list_literal\",\n            items: d[1],\n            start: tokenStart(d[0]),\n            end: tokenEnd(d[2])\n        })\n                },\n    {\"name\": \"list_items\", \"symbols\": [], \"postprocess\": () => []},\n    {\"name\": \"list_items\", \"symbols\": [\"_ml\", \"expression\", \"_ml\"], \"postprocess\": d => [d[1]]},\n    {\"name\": \"list_items\", \"symbols\": [\"_ml\", \"expression\", \"_ml\", {\"literal\":\",\"}, \"list_items\"], \"postprocess\": \n        d => [\n            d[1],\n            ...d[4]\n        ]\n                },\n    {\"name\": \"dictionary_literal\", \"symbols\": [{\"literal\":\"{\"}, \"dictionary_entries\", {\"literal\":\"}\"}], \"postprocess\": \n        d => ({\n            type: \"dictionary_literal\",\n            entries: d[1],\n            start: tokenStart(d[0]),\n            end: tokenEnd(d[2])\n        })\n                },\n    {\"name\": \"dictionary_entries\", \"symbols\": [], \"postprocess\": () => []},\n    {\"name\": \"dictionary_entries\", \"symbols\": [\"_ml\", \"dictionary_entry\", \"_ml\"], \"postprocess\": \n        d => [d[1]]\n                },\n    {\"name\": \"dictionary_entries\", \"symbols\": [\"_ml\", \"dictionary_entry\", \"_ml\", {\"literal\":\",\"}, \"dictionary_entries\"], \"postprocess\": \n        d => [d[1], ...d[4]]\n                },\n    {\"name\": \"dictionary_entry\", \"symbols\": [\"identifier\", \"_ml\", {\"literal\":\":\"}, \"_ml\", \"expression\"], \"postprocess\": \n        d => [d[0], d[4]]\n                },\n    {\"name\": \"dictionary_entry\", \"symbols\": [\"string_literal\", \"_ml\", {\"literal\":\":\"}, \"_ml\", \"expression\"], \"postprocess\": \n        d => [d[0], d[4]]\n                },\n    {\"name\": \"boolean_literal\", \"symbols\": [{\"literal\":\"true\"}], \"postprocess\": \n        d => ({\n            type: \"boolean_literal\",\n            value: true,\n            start: tokenStart(d[0]),\n            end: tokenEnd(d[0])\n        })\n                },\n    {\"name\": \"boolean_literal\", \"symbols\": [{\"literal\":\"false\"}], \"postprocess\": \n        d => ({\n            type: \"boolean_literal\",\n            value: false,\n            start: tokenStart(d[0]),\n            end: tokenEnd(d[0])\n        })\n                },\n    {\"name\": \"function_expression\", \"symbols\": [{\"literal\":\"def\"}, \"_\", {\"literal\":\"(\"}, \"_\", \"parameter_list\", \"_\", {\"literal\":\")\"}, \"_\", \"code_block\"], \"postprocess\": \n        d => ({\n            type: \"function_expression\",\n            parameters: d[4],\n            body: d[8],\n            start: tokenStart(d[0]),\n            end: d[8].end\n        })\n                },\n    {\"name\": \"line_comment\", \"symbols\": [(lexer.has(\"comment\") ? {type: \"comment\"} : comment)], \"postprocess\": convertTokenId},\n    {\"name\": \"string_literal\", \"symbols\": [(lexer.has(\"string_literal\") ? {type: \"string_literal\"} : string_literal)], \"postprocess\": convertTokenId},\n    {\"name\": \"number\", \"symbols\": [(lexer.has(\"number_literal\") ? {type: \"number_literal\"} : number_literal)], \"postprocess\": convertTokenId},\n    {\"name\": \"identifier\", \"symbols\": [(lexer.has(\"identifier\") ? {type: \"identifier\"} : identifier)], \"postprocess\": convertTokenId},\n    {\"name\": \"break\", \"symbols\": [{\"literal\":\"break\"}], \"postprocess\": convertTokenId},\n    {\"name\": \"_ml$ebnf$1\", \"symbols\": []},\n    {\"name\": \"_ml$ebnf$1\", \"symbols\": [\"_ml$ebnf$1\", \"multi_line_ws_char\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"_ml\", \"symbols\": [\"_ml$ebnf$1\"]},\n    {\"name\": \"multi_line_ws_char\", \"symbols\": [(lexer.has(\"ws\") ? {type: \"ws\"} : ws)]},\n    {\"name\": \"multi_line_ws_char\", \"symbols\": [{\"literal\":\"\\n\"}]},\n    {\"name\": \"__$ebnf$1\", \"symbols\": [(lexer.has(\"ws\") ? {type: \"ws\"} : ws)]},\n    {\"name\": \"__$ebnf$1\", \"symbols\": [\"__$ebnf$1\", (lexer.has(\"ws\") ? {type: \"ws\"} : ws)], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"__\", \"symbols\": [\"__$ebnf$1\"]},\n    {\"name\": \"_$ebnf$1\", \"symbols\": []},\n    {\"name\": \"_$ebnf$1\", \"symbols\": [\"_$ebnf$1\", (lexer.has(\"ws\") ? {type: \"ws\"} : ws)], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"_\", \"symbols\": [\"_$ebnf$1\"]}\n]\n  , ParserStart: \"input\"\n}\nif (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {\n   module.exports = grammar;\n} else {\n   window.grammar = grammar;\n}\n})();\n","/*\ntraverse(ast, (node) => {\n    return false;\n})\n*/\nexports.traverse = \nfunction traverse(node, visit) {\n    const result = visit(node);\n    if (result === false) {\n        return;\n    }\n    switch (node.type) {\n        case \"program\":\n            for (let childNode of node.statements) {\n                traverse(childNode, visit);\n            }\n            break;\n        case \"comment\":\n            break;\n        case \"function_definition\":\n            traverse(node.body, visit);\n            break;\n        case \"code_block\":\n            for (let childNode of node.statements) {\n                traverse(childNode, visit);\n            }\n            break;\n        case \"call_expression\":\n            for (let childNode of node.arguments) {\n                traverse(childNode, visit);\n            }\n            break;\n        case \"string_literal\":\n            break;\n        case \"var_assignment\":\n            traverse(node.value, visit);\n            break;\n        case \"var_reference\":\n            break;\n        case \"dictionary_literal\":\n            for (let entry of node.entries) {\n                const entryKey = entry[0];\n                const entryValue = entry[1];\n                traverse(entryKey, visit);\n                traverse(entryValue, visit);\n            }\n            break;\n        case \"list_literal\":\n            for (let item of node.items) {\n                traverse(item, visit);\n            }\n            break;\n        case \"for_loop\":\n            traverse(node.iterable, visit);\n            traverse(node.body, visit);\n            break;\n        case \"while_loop\":\n            traverse(node.condition, visit);\n            traverse(node.body, visit);\n            break;\n        case \"number_literal\":\n            break;\n        case \"boolean_literal\":\n            break;\n        case \"if_statement\":\n            traverse(node.condition, visit);\n            traverse(node.consequent, visit);\n            if (node.alternate) {\n                traverse(node.alternate, visit);\n            }\n            break;\n        case \"indexed_assignment\":\n            traverse(node.subject, visit);\n            traverse(node.index, visit);\n            break;\n        case \"binary_operation\":\n            traverse(node.left, visit);\n            traverse(node.right, visit);\n            break;\n        case \"indexed_access\":\n            traverse(node.subject, visit);\n            traverse(node.index, visit);\n            break;\n        case \"indexed_assignment\":\n            traverse(node.subject, visit);\n            traverse(node.index, visit);\n            traverse(node.value, visit);\n            break;\n        case \"function_expression\":\n            traverse(node.body, visit);\n            break;\n        case \"identifier\":\n            break;\n        case \"return_statement\":\n            if (node.value) {\n                traverse(node.value, visit);\n            }\n            break;\n        case \"not_operation\":\n            traverse(node.subject, visit);\n            break;\n        case \"while_loop\":\n            traverse(node.condition, visit);\n            traverse(node.body, visit);\n            break;\n        case \"break\":\n            break;\n        default:\n            throw new Error(\"Unhandled node type: \" + node.type);\n    }\n};\n\nexports.traverseAndCollect = function traverseAndCollect(node, visit) {\n    const result = visit(node);\n    if (result) {\n        return result;\n    }\n\n    if (node.type === \"binary_operation\") {\n        return [\n            ...traverseAndCollect(node.left, visit),\n            ...traverseAndCollect(node.right, visit)\n        ];\n    } else if (node.type === \"boolean_literal\") {\n        return [];\n    } else if (node.type === \"call_expression\") {\n        const result = [];\n        for (let arg of node.arguments) {\n            result.push(...traverseAndCollect(arg, visit));\n        }\n        return result;\n    } else if (node.type === \"code_block\" || node.type === \"program\") {\n        const result = [];\n        for (let statement of node.statements) {\n            result.push(...traverseAndCollect(statement, visit));\n        }\n        return result;\n    } else if (node.type === \"comment\") {\n        return [];\n    } else if (node.type === \"dictionary_literal\") {\n        const result = [];\n        for (let entry of node.entries) {\n            result.push(...traverseAndCollect(entry[0], visit));\n            result.push(...traverseAndCollect(entry[1], visit));\n        }\n        return result;\n    } else if (node.type === \"for_loop\") {\n        return [\n            ...traverseAndCollect(node.iterable, visit),\n            ...traverseAndCollect(node.body, visit)\n        ];\n    } else if (\n        node.type === \"function_definition\" ||\n        node.type === \"function_expression\") {\n        return traverseAndCollect(node.body, visit);\n    } else if (node.type === \"identifier\") {\n        return [];\n    } else if (node.type === \"if_statement\") {\n        const conditionClosures = traverseAndCollect(node.condition, visit);\n        const consequentClosures = traverseAndCollect(node.consequent, visit);\n        const alternateClosures =\n            node.alternate &&\n            traverseAndCollect(node.alternate, visit) ||\n            [];\n        return [\n            ...conditionClosures,\n            ...consequentClosures,\n            ...alternateClosures\n        ];\n    } else if (node.type === \"indexed_access\") {\n        return [\n            ...traverseAndCollect(node.subject, visit),\n            ...traverseAndCollect(node.index, visit)\n        ];\n    } else if (node.type === \"indexed_assignment\") {\n        return [\n            ...traverseAndCollect(node.subject, visit),\n            ...traverseAndCollect(node.index, visit),\n            ...traverseAndCollect(node.value, visit)\n        ];\n    } else if (node.type === \"list_literal\") {\n        const result = [];\n        for (let item of node.items) {\n            result.push(...traverseAndCollect(item, visit));\n        }\n        return result;\n    } else if (node.type === \"number_literal\") {\n        return [];\n    } else if (node.type === \"string_literal\") {\n        return [];\n    } else if (node.type === \"return_statement\") {\n        return traverseAndCollect(node.value, visit);\n    } else if (node.type === \"var_assignment\") {\n        return traverseAndCollect(node.value, visit);\n    } else if (node.type === \"var_reference\") {\n        return [];\n    } else if (node.type === \"while_loop\") {\n        return [\n            ...traverseAndCollect(node.condition, visit),\n            ...traverseAndCollect(node.body, visit)\n        ];\n    } else {\n        console.log(\"node\", node);\n        throw new Error(\"Unhandled node type: \" + node.type);\n    }\n}\n","import { ZoomRenderable, BoundingBox } from \"./zui\";\nimport { HistoryEntry } from \"./play-lang\";\nimport { TextMeasurer, TextBox, fitBox, Box, ContainerBox } from \"./fit-box\";\nimport { traverse } from \"../traverser\";\n\nconst CODE_LINE_HEIGHT = 1.5;\nconst CODE_FONT_FAMILY = \"Monaco\";\nconst LINE_NUMBER_COLOR = \"#489dff\";\nconst CODE_COLOR = \"black\";\nconst VARIABLE_DISPLAY_COLOR = \"#f0b155\";\n\nexport class CodeScopeRenderer implements ZoomRenderable {\n    entries: HistoryEntry[];\n    ast: any;\n    callExprCode: string;\n    code: string;\n    textMeasurer: TextMeasurer;\n    \n    constructor(entries: HistoryEntry[], callExprCode: string, ast: any, code: string, textMeasurer: TextMeasurer) {\n        this.entries = entries;\n        this.callExprCode = callExprCode;\n        this.ast = ast;\n        this.code = code;\n        this.textMeasurer = textMeasurer;\n    }\n    \n    render(\n        ctx: CanvasRenderingContext2D,\n        bbox: BoundingBox,\n        viewport: BoundingBox\n    ): Map<BoundingBox, ZoomRenderable> {\n        // TODO: move this logic to container\n        if (bbox.x + bbox.width < viewport.x ||\n            bbox.y + bbox.height < viewport.y ||\n            bbox.x > viewport.width ||\n            bbox.y > viewport.height) {\n            return new Map();\n        }\n        const myArea = bbox.width * bbox.height;\n        const myAreaRatio = myArea / (viewport.width * viewport.height);\n        const firstEntry = this.entries[0];\n        const stackFrame = firstEntry.stack[firstEntry.stack.length - 1];\n        const funName = stackFrame.funName;\n        const funNode = findFunction(this.ast, funName);\n        const userDefinedFunctions = findNodesOfType(this.ast, \"function_definition\");\n        const userDefinedFunctionNames = userDefinedFunctions.map(fun => fun.name.value);\n\n        ctx.clearRect(bbox.x, bbox.y, bbox.width, bbox.height);\n\n        const { currentEntries, childEntries } = groupHistoryEntries(funNode, this.entries, userDefinedFunctionNames);\n\n        if (myAreaRatio < 0.4) {\n            // not rendering children\n            const textBox: TextBox = {\n                type: \"text\",\n                text: this.callExprCode\n            };\n            fitBox(textBox, bbox, viewport, CODE_FONT_FAMILY, \"normal\", true, this.textMeasurer, CODE_LINE_HEIGHT, ctx);\n        } else {\n            const { codeBox, childMap } = this.getCodeBox(\n                this.code, currentEntries, childEntries, \n                userDefinedFunctionNames, this.ast\n            );\n            const bboxMap = fitBox(\n                codeBox, bbox, viewport, CODE_FONT_FAMILY, \n                \"normal\", true, this.textMeasurer, CODE_LINE_HEIGHT, ctx);\n    \n            let childRenderables: Map<BoundingBox, ZoomRenderable> = new Map();\n            for (let [box, renderable] of childMap) {\n                const childBBox = bboxMap.get(box);\n                childRenderables.set(childBBox, renderable);\n            }\n            return childRenderables;\n        }\n        return new Map();\n    }\n\n    getCodeBox(\n        code: string, \n        currentEntries: HistoryEntry[], \n        childEntries: Map<any, HistoryEntry[]>, \n        userDefinedFunctionNames: string[],\n        ast: any\n        ): { codeBox: Box, childMap: Map<Box, ZoomRenderable> } {\n        // rendering children\n        //console.log(indent + \"myAreaRatio >= 0.5\");\n        const codeLines = code.split(\"\\n\");\n        const firstEntry = currentEntries[0];\n        const stackFrame = firstEntry.stack[firstEntry.stack.length - 1];\n        const funName = stackFrame.funName;\n        const funNode = findFunction(ast, funName);\n        const lineNumberWidth = 3;\n        const childMap: Map<Box, ZoomRenderable> = new Map();\n        \n        const codeBox: Box = {\n            type: \"container\",\n            direction: \"vertical\",\n            children: []\n        };\n        // layout the function signature\n        codeBox.children.push(this.layoutFunctionSignature(funNode, stackFrame, codeLines, lineNumberWidth));\n        \n        // Go through current entries and layout the code line by line\n        for (let i = 0; i < currentEntries.length; i++) {\n            const entry = currentEntries[i];\n            const nextEntry = currentEntries[i + 1];\n            if (nextEntry && entry.line === nextEntry.line) {\n                continue;\n            }\n            const line = codeLines[entry.line - 1];\n            const lineNumberBox: TextBox = {\n                type: \"text\",\n                text: String(entry.line).padEnd(lineNumberWidth) + \"  \",\n                color: LINE_NUMBER_COLOR\n            };\n            const lineBox: ContainerBox = {\n                type: \"container\",\n                direction: \"horizontal\",\n                children: [\n                    lineNumberBox\n                ]\n            };\n            \n            // See if there are callExpr nodes\n            let curpos: number = 0;\n            const callExprNodes = findNodesOfTypeOnLine(funNode, \"call_expression\", entry.line);\n            for (let callExprNode of callExprNodes) {\n                if (!userDefinedFunctionNames.includes(callExprNode.fun_name.value)) {\n                    continue;\n                }\n                const startIdx = callExprNode.start.col;\n                const endIdx = callExprNode.end.col;\n                const previousCode = line.slice(curpos, startIdx);\n                lineBox.children.push({\n                    type: \"text\",\n                    text: previousCode,\n                    color: CODE_COLOR\n                });\n                const callExprCode = line.slice(startIdx, endIdx);\n                const callExprTextBox: TextBox = {\n                    type: \"text\",\n                    text: callExprCode,\n                    color: CODE_COLOR\n                };\n                childMap.set(\n                    callExprTextBox, \n                    new CodeScopeRenderer(\n                        childEntries.get(callExprNode), \n                        callExprCode,\n                        this.ast,\n                        this.code,\n                        this.textMeasurer\n                    )\n                );\n                lineBox.children.push(callExprTextBox);\n                curpos = endIdx;\n            }\n            // wrap up\n            const rest = line.slice(curpos);\n            if (rest.length > 0) {\n                lineBox.children.push({\n                    type: \"text\",\n                    text: rest,\n                    color: CODE_COLOR\n                });\n            }\n            \n            const valueDisplayStrings: TextBox[][] = [];\n            for (let callExprNode of callExprNodes) {\n                const myChildEntries = childEntries.get(callExprNode);\n                if (!myChildEntries) {\n                    continue;\n                }\n                const lastChildEntry = myChildEntries[myChildEntries.length - 1];\n                const lastChildEntryStackFrame = lastChildEntry.stack[lastChildEntry.stack.length - 1];\n                const funName = lastChildEntryStackFrame.funName;\n                const funDefNode = findNodesOfType(ast, \"function_definition\").find(node => node.name.value === funName);\n                const parameterList = funDefNode.parameters.map(param => {\n                    const paramName = param.value;\n                    const paramValue = lastChildEntryStackFrame.parameters[paramName];\n                    return paramValue;\n                });\n                const callExprCode = funName + \"(\" + parameterList + \")\";\n                const retVal = String(lastChildEntryStackFrame.variables[\"<ret val>\"]);\n                const actualCallExprBox: TextBox = {\n                    type: \"text\",\n                    text: `${callExprCode}`,\n                    color: VARIABLE_DISPLAY_COLOR\n                };\n                childMap.set(actualCallExprBox, new CodeScopeRenderer(\n                    childEntries.get(callExprNode),\n                    callExprCode,\n                    this.ast,\n                    this.code,\n                    this.textMeasurer\n                ));\n                valueDisplayStrings.push([\n                    actualCallExprBox,\n                    {\n                        type: \"text\",\n                        text: ` = `,\n                        color: VARIABLE_DISPLAY_COLOR\n                    },\n                    {\n                        type: \"text\",\n                        text: retVal,\n                        border: {\n                            width: 3,\n                            color: \"black\"\n                        },\n                        color: VARIABLE_DISPLAY_COLOR\n                    }\n                ]);\n            }\n            // Display variable values for assignments\n            const assignmentNode = findNodesOfTypeOnLine(funNode, \"var_assignment\", entry.line)[0];\n            if (assignmentNode) {\n                const varName = assignmentNode.var_name.value;\n                const nextStackFrame = nextEntry.stack[nextEntry.stack.length - 1];\n                let varValue = nextStackFrame.variables[varName];\n                if (typeof varValue === \"object\") {\n                    // heap reference\n                    varValue = nextEntry.heap[varValue.id];\n                }\n                const varValueDisplay = this.getVarValueDisplay(varValue, childMap, nextEntry.heap);\n                const prefix = `${varName} = `;\n                const tboxes: TextBox[][] = varValueDisplay.map((boxes, idx) => {\n                    if (idx === 0) {\n                        return [\n                            {\n                                type: \"text\",\n                                text: prefix,\n                                color: VARIABLE_DISPLAY_COLOR\n                            } as TextBox,\n                            ...boxes\n                        ];\n                    } else {\n                        return [\n                            {\n                                type: \"text\",\n                                text: Array(prefix.length + 1).join(\" \")\n                            } as TextBox,\n                            ...boxes\n                        ]\n                    }\n                });\n                valueDisplayStrings.push(...tboxes);\n            }\n            \n            // Display variable values for return statements\n            const returnStatement = findNodesOfTypeOnLine(funNode, \"return_statement\", entry.line)[0];\n            if (returnStatement) {\n                const nextStackFrame = nextEntry.stack[nextEntry.stack.length - 1];\n                const varValue = String(nextStackFrame.variables[\"<ret val>\"]);\n                valueDisplayStrings.push([\n                    {\n                        type: \"text\",\n                        text: `<ret val> = `,\n                        color: VARIABLE_DISPLAY_COLOR\n                    },\n                    {\n                        type: \"text\",\n                        text: varValue,\n                        border: {\n                            width: 3,\n                            color: \"black\"\n                        },\n                        color: VARIABLE_DISPLAY_COLOR\n                    }\n                ]);\n            }\n            \n            codeBox.children.push(lineBox);\n            \n            if (valueDisplayStrings.length > 0) {\n                lineBox.children.push({\n                    type: \"text\",\n                    text: \"  \"\n                });\n                lineBox.children.push(...valueDisplayStrings[0]);\n                for (let i = 1; i < valueDisplayStrings.length; i++) {\n                    const blankLineBox: Box = {\n                        type: \"container\",\n                        direction: \"horizontal\",\n                        children: []\n                    };\n                    blankLineBox.children.push({\n                        type: \"text\",\n                        text: \"\".padStart(lineNumberWidth + line.length + 4)\n                    });\n                    blankLineBox.children.push(...valueDisplayStrings[i]);\n                    codeBox.children.push(blankLineBox);\n                }\n            }\n            \n        }\n    \n        return {\n            codeBox,\n            childMap\n        };\n    }\n\n    layoutFunctionSignature(funNode: any, stackFrame: any, codeLines: string[], lineNumberWidth: number) {\n        const funSigBox: ContainerBox = {\n            type: \"container\",\n            direction: \"horizontal\",\n            children: [\n                {\n                    type: \"text\",\n                    text: String(funNode.start.line).padEnd(lineNumberWidth) + \"  \",\n                    color: LINE_NUMBER_COLOR\n                },\n                {\n                    type: \"text\",\n                    text: codeLines[funNode.start.line - 1],\n                    color: CODE_COLOR\n                }\n            ]\n        };\n        for (let param of funNode.parameters) {\n            const paramName = param.value;\n            const value = stackFrame.variables[paramName];\n            funSigBox.children.push({\n                type: \"text\",\n                text: `  ${paramName} = ${value}`,\n                color: VARIABLE_DISPLAY_COLOR\n            });\n        }\n        return funSigBox;\n    }\n\n    getVarValueDisplay(varValue: any, childMap: Map<Box, ZoomRenderable>, heap: any): TextBox[][] {\n        const textAttrs = {\n            border: {\n                width: 3,\n                color: \"black\"\n            },\n            color: VARIABLE_DISPLAY_COLOR\n        }\n        if (typeof varValue === \"string\") {\n            return [[{\n                type: \"text\",\n                text: '\"' + varValue + '\"',\n                ...textAttrs\n            }]];\n        } else if (Array.isArray(varValue)) {\n            const array = varValue;\n            return [array.map(item => {\n                const textBox: TextBox = {\n                    type: \"text\",\n                    text: \" \" + JSON.stringify(item) + \" \",\n                    ...textAttrs\n                };\n                if (typeof item === \"object\") {\n                    childMap.set(textBox, {\n                        render: (ctx, bbox, viewport): Map<BoundingBox, ZoomRenderable> => {\n                            const myArea = bbox.width * bbox.height;\n                            const myAreaRatio = myArea / (viewport.width * viewport.height);\n                            if (myAreaRatio > 0.001) {\n                                const value = heap[item.id];\n                                ctx.clearRect(bbox.x, bbox.y, bbox.width, bbox.height);\n                                const childMap = new Map();\n                                const rows = this.getVarValueDisplay(value, childMap, heap);\n                                const outerBox: Box = {\n                                    type: \"container\",\n                                    direction: \"vertical\",\n                                    children: rows.map((cells) => ({\n                                        type: \"container\",\n                                        direction: \"horizontal\",\n                                        children: cells\n                                    }))\n                                } as Box;\n                                const bboxMap = fitBox(outerBox, bbox, viewport, CODE_FONT_FAMILY, \"normal\", true, this.textMeasurer, CODE_LINE_HEIGHT, ctx);\n                                const childBboxMap = new Map();\n                                for (let [box, renderable] of bboxMap.entries()) {\n                                    childBboxMap.set(bboxMap.get(box), renderable);\n                                }\n                                //return childBboxMap;\n                            }\n                            return new Map();\n                        }\n                    })\n                }\n                return textBox;\n            })];\n        } else if (typeof varValue === \"object\") {\n            const dict = varValue;\n            const boxes = [];\n            for (let key in dict) {\n                const value = dict[key];\n                boxes.push([\n                    {\n                        type: \"text\",\n                        text: \" \" + key + \" \",\n                        ...textAttrs\n                    },\n                    {\n                        type: \"text\",\n                        text: \" \" + JSON.stringify(value) + \" \",\n                        ...textAttrs\n                    }\n                ]);\n            }\n            return boxes;\n        } else {\n            return [[\n                {\n                    type: \"text\",\n                    text: String(varValue),\n                    ...textAttrs\n                }\n            ]]\n        }\n    }\n\n    toString() {\n        return this.callExprCode;\n    }\n}\n\n\nfunction groupHistoryEntries(funNode, entries: HistoryEntry[], userDefinedFunctionNames: string[]) {\n    const currentStackHeight = entries[0].stack.length;\n    const childEntries: Map<any, HistoryEntry[]> = new Map();\n    const currentEntries = [];\n    \n    let currentLine: number = null;\n    let callExprs: any[] = null;\n    let currentCallExprIdx = null;\n    for (let entry of entries) {\n        if (entry.stack.length === currentStackHeight) {\n            if (currentLine !== entry.line) {\n                currentLine = entry.line;\n                // initialize context for this line\n                currentEntries.push(entry);\n                // find call expressions on this line\n                callExprs = findNodesOfTypeOnLine(funNode, \"call_expression\", entry.line)\n                    .filter(expr => userDefinedFunctionNames.includes(expr.fun_name.value));\n                currentCallExprIdx = 0;\n            } else { // currentLine === entry.line\n                currentCallExprIdx++;\n            }\n        } else {\n            // nested scope execution\n            const callExpr = callExprs[currentCallExprIdx];\n            if (!childEntries.has(callExpr)) {\n                childEntries.set(callExpr, []);\n            }\n            childEntries.get(callExpr).push(entry);\n        }\n    }\n    \n    return {\n        currentEntries,\n        childEntries\n    };\n}\n\nfunction findLine(ast, lineNo) {\n    let found;\n    traverse(ast, (node) => {\n        if (node.start && node.start.line === lineNo) {\n            found = node;\n            return false;\n        } else {\n            return undefined;\n        }\n    });\n    return found;\n}\n\nfunction findFunction(ast, name) {\n    let fun;\n    traverse(ast, (node) => {\n        if (node.type === \"function_definition\" && node.name.value === name) {\n            fun = node;\n        }\n    });\n    return fun;\n}\n\nfunction findNodesOfType(node, type) {\n    let defs = [];\n    traverse(node, (childNode) => {\n        if (childNode.type === type) {\n            defs.push(childNode);\n        }\n    });\n    return defs;\n}\n\nfunction findNodesOfTypeOnLine(node, type, lineNo) {\n    let defs = [];\n    traverse(node, (childNode) => {\n        if (childNode.type === type && childNode.start.line === lineNo) {\n            defs.push(childNode);\n        }\n    });\n    return defs;\n}","/*\nA bounding box is an rectangular area in a 2D canvas.\n*/\nexport type BoundingBox = {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n};\n\n/*\nA box is either a text box or a container box.\n*/\nexport type Box = TextBox | ContainerBox;\n\n/*\nA text box is a box that contains text. It always has type equal to \"text\".\n*/\nexport type TextBox = {\n    type: \"text\",\n    text: string,\n    color?: string\n    border?: {\n        width?: number,\n        color?: string\n    }\n};\n\n/*\nA container box is a box that contains other boxes, which in turn\ncan either be text boxes or container boxes. It always has type equal to\n\"container\". It has a direction which is either vertical or horizontal.\nAnd it has a children array which contains its children boxes.\n*/\nexport type ContainerBox = {\n    type: \"container\",\n    direction: \"vertical\" | \"horizontal\",\n    children: Box[]\n};\n\n/* A point is a coordinate on the canvas 2D plane. */\nexport type Point = {\n    y: number;\n    x: number;\n}\n\nexport type FontSetting = {\n    size: number,\n    family: string,\n    weight: string\n};\n\nexport class TextMeasurer {\n    widthTable: { [key: string]: number } = {};\n    ctx: CanvasRenderingContext2D;\n    font: string;\n    fontSetting: FontSetting;\n    fixedWidthFontRatio: { [key: string]: number } = {};\n    constructor(ctx: CanvasRenderingContext2D, private fixedWidth: boolean) {\n        this.ctx = ctx;\n    }\n    \n    setFont(fontSetting: FontSetting) {\n        this.fontSetting = fontSetting;\n        this.font = `${fontSetting.weight} ${fontSetting.size}px ${fontSetting.family}`;\n        if (this.fixedWidth) {\n            this.font = `${fontSetting.weight} ${fontSetting.size}px ${fontSetting.family}`;\n            const key = `${fontSetting.weight}-${fontSetting.family}`;\n            if (!(key in this.fixedWidthFontRatio)) {\n                this.ctx.font = `${fontSetting.weight} 10px ${fontSetting.family}`;\n                const ratio = this.ctx.measureText(\"i\").width / 10;\n                this.fixedWidthFontRatio[key] = ratio;\n            }\n        } else {\n            this.ctx.font = this.font;\n        }\n    }\n\n    measureText(text: string): number {\n        if (this.fixedWidth) {\n            const ratio = this.fixedWidthFontRatio[`${this.fontSetting.weight}-${this.fontSetting.family}`];\n            return text.length * ratio * this.fontSetting.size;\n        } else {\n            let totalWidth = 0;\n            for (let chr of text) {\n                const chrKey = chr + this.font;\n                let width = this.widthTable[chrKey];\n                if (!width) {\n                    width = this.ctx.measureText(chr).width;\n                    this.widthTable[chrKey] = width;\n                }\n                totalWidth += width;\n            }\n            \n            let width = totalWidth;\n            if (this.fontSetting.size > 10000) {\n                width = width * (this.fontSetting.size / 10000);\n            }\n            return width;\n        }\n    }\n}\n/*\nconst layoutSearchTimes: number[] = [];\nconst layoutSearchTries: number[] = [];\nconst renderTimes: number[] = [];\n\nfunction displayLayoutSearchTimeStats() {\n    const sum = layoutSearchTimes.reduce((sum, curr) => sum + curr, 0);\n    const average = sum / layoutSearchTimes.length;\n    const min = Math.min(...layoutSearchTimes);\n    const max = Math.max(...layoutSearchTimes);\n    console.log(\"layout search times\", \"avg:\", average.toFixed(1), \"min:\", min.toFixed(1), \"max:\", max.toFixed(1));\n}\n\nfunction displayLayoutSearchTriesStats() {\n    const sum = layoutSearchTries.reduce((sum, curr) => sum + curr, 0);\n    const average = sum / layoutSearchTries.length;\n    const min = Math.min(...layoutSearchTries);\n    const max = Math.max(...layoutSearchTries);\n    console.log(\"layout search tries\", \"avg:\", average.toFixed(1), \"min:\", min.toFixed(1), \"max:\", max.toFixed(1));\n}\n\nfunction displayRenderTimeStats() {\n    const sum = renderTimes.reduce((sum, curr) => sum + curr, 0);\n    const average = sum / renderTimes.length;\n    const min = Math.min(...renderTimes);\n    const max = Math.max(...renderTimes);\n    console.log(\"fitBox render times\", \"avg:\", average.toFixed(1), \"min:\", min.toFixed(1), \"max:\", max.toFixed(1));\n}\n\nsetInterval(() => {\n    displayLayoutSearchTimeStats();\n    displayLayoutSearchTriesStats();\n    displayRenderTimeStats();\n}, 5000);\n*/\n/*\nEntry point of the fit box algorithm. Given a box to calculate the layout for,\nbounding box to fit the box within, a specificed font family and font weight,\nand a canvas rendering context (2D), it will first find the best layout for the box\nto fit into the provided bounding box, and then it will render the box.\n*/\nexport function fitBox(\n    box: Box,\n    bbox: BoundingBox,\n    visibleBox: BoundingBox,\n    fontFamily: string,\n    fontWeight: string,\n    fixedWidth: boolean,\n    textMeasurer: TextMeasurer,\n    lineHeight: number,\n    ctx: CanvasRenderingContext2D\n) {\n    let lowerFontSize: null | number = null;\n    let upperFontSize: null | number = null;\n    let fontSize = 5;\n    let bboxMap;\n    ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);\n    while (true) {\n        if (fontSize === 0) {\n            throw new Error(\"Unexpected condition\");\n        }\n        textMeasurer.setFont({\n            weight: fontWeight,\n            size: fontSize,\n            family: fontFamily\n        });\n        bboxMap = layout(box, { x: bbox.x, y: bbox.y }, fontSize, textMeasurer, lineHeight);\n        const myBBox = bboxMap.get(box);\n        const allFit = myBBox.height <= bbox.height && myBBox.width <= bbox.width;\n        //console.log(`Trying fontSize: ${fontSize}, bbox.width = ${bbox.width}, bbox.height = ${bbox.height}, myBBox.width = ${myBBox.width}, myBBox.height = ${myBBox.height}`);\n        \n        if (allFit) {\n            //console.log(\"All fit\");\n            lowerFontSize = fontSize;\n            if (upperFontSize) {\n                const newFontSize = Math.floor((upperFontSize + fontSize) / 2);\n                if (newFontSize === fontSize) {\n                    //console.log(\"Break out of loop\");\n                    break;\n                }\n                fontSize = newFontSize;\n            } else {\n                fontSize *= 2;\n            }\n        } else {\n            //console.log(\"Didn't fit\");\n            upperFontSize = fontSize;\n            if (lowerFontSize) {\n                const newFontSize = Math.floor((lowerFontSize + fontSize) / 2);\n                if (newFontSize === fontSize) {\n                    break;\n                }\n                fontSize = newFontSize;\n            } else {\n                fontSize = Math.floor(fontSize / 2);\n            }\n        }\n    }\n    \n    \n    \n    //console.log(\"font size:\", fontSize);\n    ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\n    const resultBBox = bboxMap.get(box);\n    // compare resultBBox to bbox\n    const xOffset = (bbox.width - resultBBox.width) / 2;\n    const yOffset = (bbox.height - resultBBox.height) / 2;\n    for (let aBox of bboxMap.keys()) {\n        const aBBox = bboxMap.get(aBox);\n        aBBox.x += xOffset;\n        aBBox.y += yOffset;\n    }\n    render(box, bboxMap, visibleBox, fontSize, lineHeight, ctx);\n    return bboxMap;\n}\n\n/*\nGiven a box, an offset, a font size, and a canvas rendering context. layout calculates\na bounding box for each box (parents and descendents included) as a map that maps a Box\nto a BoundingBox.\n*/\nexport function layout(\n    box: Box, \n    offset: Point,\n    fontSize: number,\n    textMeasurer: TextMeasurer, \n    lineHeight: number):\n    Map<Box, BoundingBox> {\n    if (box.type === \"text\") {\n        if (typeof box.text !== \"string\") {\n            throw new Error(\"BLARGH\");\n        }\n        let width = textMeasurer.measureText(box.text);\n        //console.log(\"measureText:\", box.text, fontSize, \"=\", width);\n        const height = fontSize * lineHeight;\n        const bbox: BoundingBox = {\n            ...offset,\n            width: width,\n            height\n        };\n        return new Map([[box, bbox]]);\n    } else if (box.type === \"container\") {\n        if (box.direction === \"vertical\") {\n            const entries = [];\n            let yOffset = offset.y;\n            let myWidth = 0;\n            let myHeight = 0;\n            for (let child of box.children) {\n                const bboxMap = layout(\n                    child, \n                    { x: offset.x, y: yOffset }, \n                    fontSize, \n                    textMeasurer,\n                    lineHeight\n                );\n                entries.push(...bboxMap);\n                const childBBox = bboxMap.get(child);\n                let previousYOffset = yOffset;\n                yOffset += childBBox.height;\n                if (previousYOffset >= 0 && yOffset < 0) {\n                    throw new Error(`Number wrapped around: ${previousYOffset}, ${childBBox.height}, ${yOffset}`);\n                }\n                myHeight += childBBox.height;\n                if (childBBox.width > myWidth) {\n                    myWidth = childBBox.width;\n                }\n            }\n            const containerBBox: BoundingBox = {\n                ...offset,\n                height: myHeight,\n                width: myWidth\n            };\n            entries.push([box, containerBBox]);\n            return new Map(entries);\n        } else if (box.direction === \"horizontal\") {\n            const entries = [];\n            let xOffset = offset.x;\n            let myWidth = 0;\n            let myHeight = 0;\n            for (let child of box.children) {\n                const bboxMap = layout(\n                    child, \n                    { x: xOffset, y: offset.y }, \n                    fontSize, \n                    textMeasurer,\n                    lineHeight\n                );\n                entries.push(...bboxMap);\n                const childBBox = bboxMap.get(child);\n                let previousXOffset = xOffset;\n                xOffset += childBBox.width;\n                if (previousXOffset >= 0 && xOffset < 0) {\n                    throw new Error(`Number wrapped around: ${previousXOffset}, ${childBBox.width}, ${xOffset}`);\n                }\n                myWidth += childBBox.width;\n                if (childBBox.height > myHeight) {\n                    myHeight = childBBox.height;\n                }\n            }\n            const containerBBox: BoundingBox = {\n                ...offset,\n                height: myHeight,\n                width: myWidth\n            };\n            entries.push([box, containerBBox]);\n            return new Map(entries);\n        } else {\n            throw new Error(\"Not implemented\");\n        }\n    } else {\n        throw new Error(\"Not implemented\");\n    }\n}\n\n/*\nGiven a box and a mapping between box and bounding box (you can get\nfrom layout, and a canvas rendering context, renders the box.\n\nPre-condition: You set the font property on the canvas context.\n*/\nexport function render(\n    box: Box,\n    bBoxMap: Map<Box, BoundingBox>,\n    visibleBox: BoundingBox,\n    fontSize: number,\n    lineHeight: number,\n    ctx: CanvasRenderingContext2D): void\n    {\n    const mybbox = bBoxMap.get(box);\n    if (mybbox.x + mybbox.width < visibleBox.x ||\n        mybbox.y + mybbox.height < visibleBox.y ||\n        mybbox.x > visibleBox.width ||\n        mybbox.y > visibleBox.height) {\n        return;\n    }\n    if (box.type === \"text\") {\n        ctx.save();\n        if (box.color) {\n            ctx.fillStyle = box.color;\n        }\n        const yOffset = fontSize * ((lineHeight - 1) / 2);\n        if (box.border) {\n            const width = box.border.width || 1;\n            const color = box.border.color || \"black\";\n            ctx.strokeStyle = color;\n            ctx.lineWidth = width;\n            ctx.strokeRect(mybbox.x, mybbox.y, mybbox.width, mybbox.height);\n        }\n        ctx.fillText(box.text, mybbox.x, mybbox.y + yOffset);\n        ctx.restore();\n    } else if (box.type === \"container\") {\n        for (let child of box.children) {\n            render(child, bBoxMap, visibleBox, fontSize, lineHeight, ctx);\n        }\n    } else {\n        throw new Error(\"Not implemented\");\n    }    \n}\n\n/*\nGiven a bounding box, and the canvas rendering context, draw its outline. \n*/\nexport function strokeBBox(bbox: BoundingBox, ctx: CanvasRenderingContext2D) {\n    ctx.strokeRect(\n        bbox.x, \n        bbox.y,\n        bbox.width,\n        bbox.height\n    );\n}\n","import { parse } from \"../parser\";\nimport { BoundingBox, TextMeasurer } from \"./fit-box\";\nimport { ZoomRenderable } from \"./zui\";\nimport { HistoryEntry } from \"./play-lang\";\nimport { CodeScopeRenderer } from \"./code-scope-renderer\";\n\ntype Scope = {\n    bbox: BoundingBox,\n    renderable: ZoomRenderable\n};\n\nexport function initZoomDebugger(element: HTMLElement, code: string, history: HistoryEntry[]) {\n    const canvasWidth = element.offsetWidth * 2;\n    const canvasHeight = element.offsetHeight * 2;\n    if (canvasWidth === 0 || canvasHeight === 0) {\n        throw new Error(`Container element has 0 dimension.`);\n    }\n    let dragging = false;\n    let dragStartX: number;\n    let dragStartY: number;\n    const ast = parse(code);\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    canvas.style.border = \"1px solid black\";\n    canvas.style.transform = `scale(0.5) translate(-${canvas.width / 2}px, -${canvas.height / 2}px)`;\n\n    let viewport = {\n        top: - canvas.height / 2,\n        left: - canvas.width / 2,\n        zoom: 0.5\n    };\n    \n    const ctx = canvas.getContext(\"2d\");\n\n    element.appendChild(canvas);\n    ctx.textBaseline = \"top\";\n    const textMeasurer = new TextMeasurer(ctx, true);\n    \n    const mainScope: Scope = {\n        bbox: {\n            y: 0,\n            x: 0,\n            width: canvas.width,\n            height: canvas.height\n        },\n        renderable: new CodeScopeRenderer(history, \"main()\", ast, code, textMeasurer)\n    };\n    \n    let currentScopeChain: Scope[] = [mainScope];\n    // Scope chain looks like [inner most, middle scope, outer most]\n\n    requestRender();\n    \n    element.addEventListener(\"mousedown\", (e: MouseEvent) => {\n        dragging = true;\n        [dragStartX, dragStartY] = pointScreenToCanvas(e);\n    });\n\n    element.addEventListener(\"mouseup\", () => {\n        dragging = false;\n    });\n\n    element.addEventListener(\"mousemove\", (e: MouseEvent) => {\n        if (dragging) {\n            const [pointerX, pointerY] = pointScreenToCanvas(e);\n            const [worldPointerX, worldPointerY] = pointCanvasToWorld(pointerX, pointerY);\n            const [worldDragStartX, worldDragStartY] = pointCanvasToWorld(dragStartX, dragStartY);\n            viewport.left -= worldPointerX - worldDragStartX;\n            viewport.top -= worldPointerY - worldDragStartY;\n            dragStartX = pointerX;\n            dragStartY = pointerY;\n            requestRender();\n        }\n    });\n    \n    element.addEventListener(\"wheel\", function (e: any) {\n        e.preventDefault();\n        const delta = e.deltaY;\n        const [pointerX, pointerY] = pointScreenToCanvas(e);\n        const newZoom = Math.max(0.5, viewport.zoom * (1 - delta * 0.01));\n\n        const [worldPointerX, worldPointerY] = pointCanvasToWorld(pointerX, pointerY);\n        const newLeft = - (pointerX / newZoom - worldPointerX);\n        const newTop = - (pointerY / newZoom - worldPointerY);\n        const newViewport = {\n            top: newTop,\n            left: newLeft,\n            zoom: newZoom\n        };\n        viewport = newViewport;\n        \n        requestRender();\n      }, { passive: false });\n\n    function requestRender() {\n        requestAnimationFrame(render);\n    }\n    \n    function entirelyContainsViewport(bbox) {\n        return bbox.x <= 0 && bbox.y <= 0 &&\n            (bbox.x + bbox.width > canvasWidth) && \n            (bbox.y + bbox.height > canvasHeight);\n    }\n    \n    function renderZoomRenderable(renderable: ZoomRenderable, bbox: BoundingBox, ancestry: Scope[]): Scope[] | null {\n        const viewportBBox = { x: 0, y: 0, width: canvas.width, height: canvas.height };\n        const childRenderables = renderable.render(ctx, bbox, viewportBBox);\n        let childEnclosingRenderable: Scope[] | null = null;\n        const myScope = {\n            bbox: boxCanvasToWorld(bbox),\n            renderable\n        };\n        for (let [childBBox, renderable] of childRenderables.entries()) {\n            const result = renderZoomRenderable(renderable, childBBox, [myScope, ...ancestry]);\n            if (result) {\n                childEnclosingRenderable = result;\n            }\n        }\n        if (childEnclosingRenderable) {\n            return childEnclosingRenderable;\n        } else {\n            if (entirelyContainsViewport(bbox)) {\n                return [myScope, ...ancestry];\n            } else {\n                return null;\n            }\n        }\n    }\n    \n    function render() {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        const currentScope = currentScopeChain[0];\n        const bBox = boxWorldToCanvas(currentScope.bbox);\n        const enclosingScopeChain = renderZoomRenderable(currentScope.renderable, bBox, currentScopeChain.slice(1));\n        if (enclosingScopeChain) {\n            currentScopeChain = enclosingScopeChain;\n        } else {\n            if (currentScopeChain.length > 1) {\n                currentScopeChain = currentScopeChain.slice(1);\n            } else {\n                currentScopeChain = [mainScope];\n            }\n        }\n    }\n    \n    function pointScreenToCanvas(e: MouseEvent): [number, number] {\n        return [\n            e.offsetX,\n            e.offsetY\n        ];\n    }\n    \n    function pointCanvasToWorld(x: number, y: number): [number, number] {\n        return [\n            x / viewport.zoom + viewport.left,\n            y / viewport.zoom + viewport.top\n        ];\n    }\n\n    function boxWorldToCanvas(box: BoundingBox): BoundingBox {\n        return {\n            y: (box.y - viewport.top) * viewport.zoom,\n            x: (box.x - viewport.left) * viewport.zoom,\n            width: box.width * viewport.zoom,\n            height: box.height * viewport.zoom\n        };\n    }\n    \n    function boxCanvasToWorld(box: BoundingBox): BoundingBox {\n        return {\n            y: (box.y / viewport.zoom) + viewport.top,\n            x: (box.x / viewport.zoom) + viewport.left,\n            width: box.width / viewport.zoom,\n            height: box.height / viewport.zoom\n        };\n    }\n    \n}\n\n"],"sourceRoot":""}